<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Realistic Luminous Rose - Valentine's Day</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1410 0%, #2a1c14 50%, #1f1612 100%);
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }

        #canvas-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        canvas {
            display: block;
        }

        .loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #1a1410;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            transition: opacity 0.8s;
        }

        .loading.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .loading-spinner {
            width: 80px;
            height: 80px;
            border: 5px solid rgba(255, 140, 60, 0.2);
            border-top: 5px solid #ff8c3c;
            border-radius: 50%;
            animation: spin 1.2s ease-in-out infinite;
            margin-bottom: 30px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .loading-text {
            color: #ffa040;
            font-size: 24px;
            text-shadow: 0 0 20px rgba(255, 140, 60, 0.6);
            margin-bottom: 10px;
        }

        .loading-subtext {
            color: rgba(244, 164, 96, 0.8);
            font-size: 14px;
        }

        .title {
            position: fixed;
            top: 40px;
            left: 50%;
            transform: translateX(-50%);
            color: #ffa040;
            font-size: 32px;
            font-weight: 300;
            letter-spacing: 4px;
            text-shadow: 0 0 30px rgba(255, 140, 60, 0.8);
            z-index: 10;
            pointer-events: none;
            text-align: center;
        }

        .subtitle {
            position: fixed;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(244, 164, 96, 0.9);
            font-size: 18px;
            text-shadow: 0 0 15px rgba(255, 140, 60, 0.5);
            z-index: 10;
            pointer-events: none;
        }

        .hint {
            position: fixed;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(244, 164, 96, 0.6);
            font-size: 12px;
            z-index: 10;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div class="loading" id="loading">
        <div class="loading-spinner"></div>
        <div class="loading-text">Blooming Rose...</div>
        <div class="loading-subtext">Creating realistic petals and stem</div>
    </div>

    <div class="title">üíù For Amber üíù</div>
    <div class="hint">Pwede mo e drag or scroll haha</div>
    <div class="subtitle">Happy Valentine's Day</div>

    <div id="canvas-container"></div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
        let scene, camera, renderer, rose;
        let petals = [];
        let isDragging = false;
        let previousMouseX = 0, previousMouseY = 0;
        let targetRotationX = 0.2, targetRotationY = 0;
        let currentRotationX = 0.2, currentRotationY = 0;
        let targetZoom = 12, currentZoom = 12;

        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x1a1410, 15, 40);

            // Camera
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 12);
            camera.lookAt(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Lighting
            setupAdvancedLighting();

            // Create the realistic rose
            createRealisticRose();

            // Events
            setupEvents();

            // Hide loading
            setTimeout(() => {
                document.getElementById('loading').classList.add('hidden');
            }, 1500);

            // Animate
            animate();
        }

        function setupAdvancedLighting() {
            // Warm ambient
            const ambient = new THREE.AmbientLight(0xffb580, 0.5);
            scene.add(ambient);

            // Main key light (warm golden from top-right)
            const keyLight = new THREE.DirectionalLight(0xffcc88, 1.5);
            keyLight.position.set(8, 12, 6);
            keyLight.castShadow = true;
            keyLight.shadow.mapSize.width = 2048;
            keyLight.shadow.mapSize.height = 2048;
            keyLight.shadow.camera.near = 0.5;
            keyLight.shadow.camera.far = 50;
            scene.add(keyLight);

            // Backlight (creates rim lighting and translucency)
            const backLight = new THREE.DirectionalLight(0xff9955, 1.8);
            backLight.position.set(-5, 3, -8);
            scene.add(backLight);

            // Fill light (soft from side)
            const fillLight = new THREE.DirectionalLight(0xffa066, 0.8);
            fillLight.position.set(-6, 2, 4);
            scene.add(fillLight);

            // Point lights for glow effect
            const pointLight1 = new THREE.PointLight(0xff8844, 1.5, 15);
            pointLight1.position.set(0, 4, 3);
            scene.add(pointLight1);

            const pointLight2 = new THREE.PointLight(0xffaa66, 1.0, 12);
            pointLight2.position.set(0, -2, 0);
            scene.add(pointLight2);

            // Subtle hemisphere light for natural feel
            const hemiLight = new THREE.HemisphereLight(0xffddaa, 0x4a2a1a, 0.6);
            scene.add(hemiLight);
        }

        function createRealisticRose() {
            rose = new THREE.Group();

            // Create curved stem (pedicle)
            createCurvedStem();

            // Create leaves
            createLeaves();

            // Create realistic rose bloom with multiple petal layers
            createRoseBud();

            scene.add(rose);
        }

        function createCurvedStem() {
            // Create a natural curved stem using CatmullRomCurve3
            const stemCurve = new THREE.CatmullRomCurve3([
                new THREE.Vector3(0, -8, 0),
                new THREE.Vector3(-0.3, -6, 0.2),
                new THREE.Vector3(-0.2, -4, 0.1),
                new THREE.Vector3(0.1, -2, -0.1),
                new THREE.Vector3(0, 0, 0)
            ]);

            // Create tube geometry along the curve
            const stemGeometry = new THREE.TubeGeometry(stemCurve, 64, 0.12, 12, false);
            
            // Realistic stem material
            const stemMaterial = new THREE.MeshPhongMaterial({
                color: 0x3d5a2f,
                shininess: 15,
                specular: 0x223311,
                bumpScale: 0.3
            });

            const stem = new THREE.Mesh(stemGeometry, stemMaterial);
            stem.castShadow = true;
            stem.receiveShadow = true;
            rose.add(stem);

            // Add thorns along the stem
            addThorns(stemCurve);
        }

        function addThorns(stemCurve) {
            const thornPositions = [0.2, 0.35, 0.5, 0.65, 0.8];
            
            thornPositions.forEach(t => {
                const point = stemCurve.getPoint(t);
                const tangent = stemCurve.getTangent(t);
                
                // Create thorn geometry
                const thornGeometry = new THREE.ConeGeometry(0.06, 0.25, 8);
                const thornMaterial = new THREE.MeshPhongMaterial({
                    color: 0x4a3a2a,
                    shininess: 20
                });
                
                const thorn = new THREE.Mesh(thornGeometry, thornMaterial);
                thorn.position.copy(point);
                
                // Orient thorn perpendicular to stem
                const axis = new THREE.Vector3(0, 1, 0);
                const angle = Math.acos(tangent.dot(axis));
                const rotationAxis = new THREE.Vector3().crossVectors(axis, tangent).normalize();
                thorn.quaternion.setFromAxisAngle(rotationAxis, angle);
                thorn.rotateZ(Math.random() * Math.PI * 2);
                thorn.rotateX(Math.PI / 6);
                
                thorn.castShadow = true;
                rose.add(thorn);
            });
        }

        function createLeaves() {
            // Create 2-3 realistic leaves along the stem
            const leafPositions = [
                { y: -3.5, angle: 0.8, scale: 1.0 },
                { y: -5.0, angle: -0.5, scale: 0.9 },
                { y: -6.5, angle: 1.2, scale: 0.85 }
            ];

            leafPositions.forEach(pos => {
                const leaf = createSingleLeaf();
                leaf.position.set(0, pos.y, 0);
                leaf.rotation.z = pos.angle;
                leaf.scale.multiplyScalar(pos.scale);
                rose.add(leaf);
            });
        }

        function createSingleLeaf() {
            const leafGroup = new THREE.Group();

            // Leaf shape using custom bezier curves
            const leafShape = new THREE.Shape();
            leafShape.moveTo(0, 0);
            leafShape.bezierCurveTo(0.3, 0.2, 0.6, 0.6, 0.7, 1.2);
            leafShape.bezierCurveTo(0.65, 1.5, 0.4, 1.7, 0, 1.8);
            leafShape.bezierCurveTo(-0.4, 1.7, -0.65, 1.5, -0.7, 1.2);
            leafShape.bezierCurveTo(-0.6, 0.6, -0.3, 0.2, 0, 0);

            const extrudeSettings = {
                depth: 0.02,
                bevelEnabled: true,
                bevelThickness: 0.01,
                bevelSize: 0.01,
                bevelSegments: 2
            };

            const leafGeometry = new THREE.ExtrudeGeometry(leafShape, extrudeSettings);
            
            // Realistic leaf material
            const leafMaterial = new THREE.MeshPhongMaterial({
                color: 0x2a4a1f,
                emissive: 0x0a1505,
                side: THREE.DoubleSide,
                shininess: 40,
                specular: 0x1a3a0f,
                transparent: true,
                opacity: 0.95
            });

            const leafMesh = new THREE.Mesh(leafGeometry, leafMaterial);
            leafMesh.castShadow = true;
            leafMesh.receiveShadow = true;
            leafMesh.rotation.x = Math.PI / 2;

            // Add veins to leaf
            const veinMaterial = new THREE.LineBasicMaterial({
                color: 0x1a2a0f,
                opacity: 0.7,
                transparent: true
            });

            // Central vein
            const centralVeinGeometry = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(0, 0, 0.03),
                new THREE.Vector3(0, 1.7, 0.03)
            ]);
            const centralVein = new THREE.Line(centralVeinGeometry, veinMaterial);
            centralVein.rotation.x = Math.PI / 2;
            leafGroup.add(centralVein);

            leafGroup.add(leafMesh);
            return leafGroup;
        }

        function createRoseBud() {
            const budGroup = new THREE.Group();

            // Create center receptacle
            const centerGeo = new THREE.SphereGeometry(0.4, 32, 32);
            const centerMat = new THREE.MeshPhongMaterial({
                color: 0x6a3a1a,
                shininess: 25,
                emissive: 0x2a1505
            });
            const center = new THREE.Mesh(centerGeo, centerMat);
            center.position.y = 0.2;
            center.castShadow = true;
            budGroup.add(center);

            // Create multiple layers of petals (12 petals total in 3 layers)
            createPetalLayer(budGroup, 4, 1.8, 0.3, 0);      // Outer layer - 4 petals
            createPetalLayer(budGroup, 4, 1.4, 0.2, Math.PI / 8);  // Middle layer - 4 petals
            createPetalLayer(budGroup, 4, 1.0, 0.15, 0);     // Inner layer - 4 petals

            budGroup.position.y = 0;
            rose.add(budGroup);
        }

        function createPetalLayer(parent, count, size, yOffset, angleOffset) {
            const angleStep = (Math.PI * 2) / count;

            for (let i = 0; i < count; i++) {
                const angle = i * angleStep + angleOffset;
                const petal = createRealisticPetal(size);
                
                petal.position.y = yOffset;
                petal.rotation.z = angle;
                petal.rotation.x = Math.PI / 2.5 + (Math.random() - 0.5) * 0.3;
                
                // Natural variation
                const curlAmount = (Math.random() - 0.5) * 0.4;
                petal.rotation.y = curlAmount;
                
                // Store for animation
                petal.userData = {
                    baseRotationY: petal.rotation.y,
                    animOffset: i * 0.3,
                    size: size
                };
                
                petals.push(petal);
                parent.add(petal);
            }
        }

        function createRealisticPetal(size) {
            const petalGroup = new THREE.Group();

            // More organic petal shape
            const petalShape = new THREE.Shape();
            const scale = size / 1.8;
            
            petalShape.moveTo(0, 0);
            petalShape.bezierCurveTo(0.4 * scale, 0.1 * scale, 0.7 * scale, 0.5 * scale, 0.9 * scale, 1.0 * scale);
            petalShape.bezierCurveTo(0.95 * scale, 1.6 * scale, 0.7 * scale, 2.1 * scale, 0.3 * scale, 2.4 * scale);
            petalShape.bezierCurveTo(0.1 * scale, 2.5 * scale, -0.1 * scale, 2.5 * scale, -0.3 * scale, 2.4 * scale);
            petalShape.bezierCurveTo(-0.7 * scale, 2.1 * scale, -0.95 * scale, 1.6 * scale, -0.9 * scale, 1.0 * scale);
            petalShape.bezierCurveTo(-0.7 * scale, 0.5 * scale, -0.4 * scale, 0.1 * scale, 0, 0);

            const extrudeSettings = {
                depth: 0.08 * scale,
                bevelEnabled: true,
                bevelThickness: 0.04 * scale,
                bevelSize: 0.03 * scale,
                bevelSegments: 4
            };

            const petalGeometry = new THREE.ExtrudeGeometry(petalShape, extrudeSettings);
            
            // Gradient-like effect through vertex colors
            const petalMaterial = new THREE.MeshPhongMaterial({
                color: 0xffaa66,
                emissive: 0xff7733,
                emissiveIntensity: 0.4,
                transparent: true,
                opacity: 0.92,
                side: THREE.DoubleSide,
                shininess: 70,
                specular: 0xffcc88,
                reflectivity: 0.3
            });

            const petalMesh = new THREE.Mesh(petalGeometry, petalMaterial);
            petalMesh.castShadow = true;
            petalMesh.receiveShadow = true;

            // Create detailed veins
            createDetailedVeins(petalGroup, petalShape, scale);

            petalGroup.add(petalMesh);
            return petalGroup;
        }

        function createDetailedVeins(petalGroup, shape, scale) {
            const veinMaterial = new THREE.LineBasicMaterial({
                color: 0xdd6633,
                opacity: 0.5,
                transparent: true,
                linewidth: 1.5
            });

            // Central vein
            const centralPoints = [
                new THREE.Vector3(0, 0, 0.09 * scale),
                new THREE.Vector3(0, 0.8 * scale, 0.09 * scale),
                new THREE.Vector3(0, 1.6 * scale, 0.09 * scale),
                new THREE.Vector3(0, 2.3 * scale, 0.09 * scale)
            ];
            const centralVeinGeo = new THREE.BufferGeometry().setFromPoints(centralPoints);
            const centralVein = new THREE.Line(centralVeinGeo, veinMaterial);
            petalGroup.add(centralVein);

            // Side veins (more detailed)
            for (let i = 0; i < 8; i++) {
                const t = (i + 1) / 9;
                const y = t * 2.3 * scale;
                const xOffset = Math.sin(t * Math.PI) * 0.8 * scale;
                const curvature = Math.pow(t, 0.7) * 0.1 * scale;

                // Right vein
                const rightVeinPoints = [
                    new THREE.Vector3(0, y, 0.09 * scale),
                    new THREE.Vector3(xOffset * 0.5, y + curvature, 0.09 * scale),
                    new THREE.Vector3(xOffset, y + curvature * 2, 0.09 * scale)
                ];
                const rightVeinGeo = new THREE.BufferGeometry().setFromPoints(rightVeinPoints);
                const rightVein = new THREE.Line(rightVeinGeo, veinMaterial);
                petalGroup.add(rightVein);

                // Left vein (mirror)
                const leftVeinPoints = [
                    new THREE.Vector3(0, y, 0.09 * scale),
                    new THREE.Vector3(-xOffset * 0.5, y + curvature, 0.09 * scale),
                    new THREE.Vector3(-xOffset, y + curvature * 2, 0.09 * scale)
                ];
                const leftVeinGeo = new THREE.BufferGeometry().setFromPoints(leftVeinPoints);
                const leftVein = new THREE.Line(leftVeinGeo, veinMaterial);
                petalGroup.add(leftVein);
            }
        }

        function setupEvents() {
            // Mouse drag
            renderer.domElement.addEventListener('mousedown', (e) => {
                isDragging = true;
                previousMouseX = e.clientX;
                previousMouseY = e.clientY;
            });

            document.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    const deltaX = e.clientX - previousMouseX;
                    const deltaY = e.clientY - previousMouseY;
                    
                    targetRotationY += deltaX * 0.005;
                    targetRotationX += deltaY * 0.005;
                    targetRotationX = Math.max(-Math.PI / 3, Math.min(Math.PI / 3, targetRotationX));
                    
                    previousMouseX = e.clientX;
                    previousMouseY = e.clientY;
                }
            });

            document.addEventListener('mouseup', () => {
                isDragging = false;
            });

            // Touch events
            renderer.domElement.addEventListener('touchstart', (e) => {
                isDragging = true;
                previousMouseX = e.touches[0].clientX;
                previousMouseY = e.touches[0].clientY;
            });

            renderer.domElement.addEventListener('touchmove', (e) => {
                if (isDragging) {
                    const deltaX = e.touches[0].clientX - previousMouseX;
                    const deltaY = e.touches[0].clientY - previousMouseY;
                    
                    targetRotationY += deltaX * 0.005;
                    targetRotationX += deltaY * 0.005;
                    targetRotationX = Math.max(-Math.PI / 3, Math.min(Math.PI / 3, targetRotationX));
                    
                    previousMouseX = e.touches[0].clientX;
                    previousMouseY = e.touches[0].clientY;
                }
            });

            renderer.domElement.addEventListener('touchend', () => {
                isDragging = false;
            });

            // Mouse wheel zoom
            renderer.domElement.addEventListener('wheel', (e) => {
                e.preventDefault();
                targetZoom += e.deltaY * 0.01;
                targetZoom = Math.max(6, Math.min(20, targetZoom));
            });

            // Window resize
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        function animate() {
            requestAnimationFrame(animate);

            const time = Date.now() * 0.001;

            // Smooth rotation
            currentRotationX += (targetRotationX - currentRotationX) * 0.1;
            currentRotationY += (targetRotationY - currentRotationY) * 0.1;
            currentZoom += (targetZoom - currentZoom) * 0.1;

            rose.rotation.x = currentRotationX;
            rose.rotation.y = currentRotationY;

            // Gentle auto-rotation when not dragging
            if (!isDragging) {
                targetRotationY += 0.002;
            }

            // Subtle petal breathing animation
            petals.forEach((petal, index) => {
                const breathe = Math.sin(time * 0.6 + petal.userData.animOffset) * 0.03;
                petal.rotation.y = petal.userData.baseRotationY + breathe;
                
                // Slight vertical movement
                const sway = Math.sin(time * 0.4 + petal.userData.animOffset * 0.5) * 0.02;
                petal.position.y = petal.userData.yBase || petal.position.y;
                if (!petal.userData.yBase) petal.userData.yBase = petal.position.y;
                petal.position.y = petal.userData.yBase + sway;
            });

            // Camera zoom
            camera.position.z = currentZoom;

            // Subtle camera movement
            camera.position.x = Math.sin(time * 0.15) * 0.3;
            camera.position.y = 5 + Math.cos(time * 0.2) * 0.2;
            camera.lookAt(0, 0, 0);

            renderer.render(scene, camera);
        }

        // Initialize
        init();
    </script>
</body>
</html>